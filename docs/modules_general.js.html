<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: modules/general.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: modules/general.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Discord = require('discord.js');
const fetch = require('node-fetch');
const probe = require('probe-image-size');
const constants = require('./constants.js');
const functions = require('./functions.js');
const classes = require('./classes.js');
/** @type {import('./app.js')} */
let app;
/** @type {import('./error_manager.js')} */
let error_manager;
/** @type {import('./message_manager.js')} */
let message_manager;
/** @type {import('./reaction_manager.js')} */
let reaction_manager;
/** @type {import('./role_manager.js')} */
let role_manager;
/** @type {import('./channel_manager.js')} */
let channel_manager;
/** @type {import('./database.js')} */
let database;
/** @type {import('./speech.js')} */
let speech;

const ErrorTicketManager = new classes.ErrorTicketManager('general.js');
const OfflineManager = new classes.ProcessQueue(1000);
const ActivityManager = new classes.ProcessQueue(5000);
const VoiceManager = new classes.ProcessQueue(1000);
const DedicateManager = new classes.ProcessQueue(10000);
const FreeGameManager = new classes.ProcessQueue(1500000);
let freeGameCollection = new Array();

/**
 * Initializes the module.
 * @param {Function} ModulesFunction The GlobalModules function.
 */
module.exports.initialize = (ModulesFunction) => {
    // Link
    const Modules = functions.parseModules(ModulesFunction);
    app = Modules.app;
    error_manager = Modules.error_manager;
    message_manager = Modules.message_manager;
    reaction_manager = Modules.reaction_manager;
    role_manager = Modules.role_manager;
    channel_manager = Modules.channel_manager;
    database = Modules.database;
    speech = Modules.speech;
}

/**
 * Checks for users on the server with no member role.
 */
module.exports.memberUnlisted = async () => {
    try {
        for (const this_member of app.guild().members.cache.array()) {
            // Check if any member doesnt have member role
            if (!this_member.user.bot &amp;&amp; !app.hasRole(this_member, [constants.roles.member])) {
                const created_from = functions.compareDate(this_member.user.createdAt);
                const embed = new Discord.MessageEmbed();
                embed.setAuthor('Quarantine Gaming: Unlisted Member');
                embed.setTitle('Member Details');
                embed.setThumbnail(this_member.user.displayAvatarURL());
                embed.addFields([
                    { name: 'User:', value: this_member },
                    { name: 'ID:', value: this_member.id },
                    { name: 'Account Created:', value: created_from.days + " days " + created_from.hours + " hours " + created_from.minutes + " minutes" }
                ]);
                embed.setColor('#ff5f5f');

                await message_manager.sendToChannel(constants.channels.server.management, {
                    content: `This user doesn't have a member role. Manual action is required.`,
                    embed: embed
                });
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('memberUnlisted', error));
    }
}

/**
 * Performs processes that clears the status of this member on this server.
 * @param {Discord.GuildMember} member The guild member object.
 */
module.exports.memberOffline = async (member) => {
    await OfflineManager.queue();
    try {
        // Remove Streaming Role
        if (app.hasRole(member, [constants.roles.streaming])) {
            await role_manager.remove(member, constants.roles.streaming);
        }

        // Remove Dedicated Channel Role
        if (app.hasRole(member, [constants.roles.dedicated])) {
            await role_manager.remove(member, constants.roles.dedicated);
        }

        // Remove all Dedicated Channel's Text Channel Roles
        let text_channel_role = null;
        do {
            text_channel_role = member.roles.cache.find(role => role.name.startsWith('Text'));
            if (text_channel_role) await role_manager.remove(member, text_channel_role);
        } while (text_channel_role);

        // Remove all Team Roles
        let team_role = null;
        do {
            team_role = member.roles.cache.find(role => role.name.startsWith('Team'));
            if (team_role) await role_manager.remove(member, team_role);
        } while (team_role);
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('memberOffline', error));
    }
    OfflineManager.finish();
}

/**
 * Performs processes that updates the status of this member through this activity.
 * @param {Discord.GuildMember} member The guild member object.
 * @param {{activity: Discord.Activity, new: Boolean}} data The activity and state of this change.
 */
module.exports.memberActivityUpdate = async (member, data) => {
    await ActivityManager.queue();
    try {
        const activity = data.activity;
        const activity_name = activity.name.trim();
        if (activity.type == 'PLAYING' &amp;&amp; !database.gameTitles().blacklisted.includes(activity_name.toLowerCase()) &amp;&amp; (activity.applicationID || database.gameTitles().whitelisted.includes(activity_name.toLowerCase()))) {
            const streaming_role = app.role(constants.roles.streaming);
            const game_role = app.guild().roles.cache.find(role => role.name == activity_name) || await role_manager.create({ name: activity_name, color: '0x00ffff' });
            let play_role = app.guild().roles.cache.find(role => role.name == 'Play ' + activity_name);

            if (!app.guild().roles.cache.find(role => role.name == activity_name + ' ⭐')) await role_manager.create({ name: activity_name + ' ⭐', color: '0x00fffe' });

            if (data.new) {
                if (play_role) {
                    // Bring Play Role to Top
                    await play_role.setPosition(streaming_role.position - 1);
                } else {
                    // Create Play Role
                    play_role = await role_manager.create({ name: 'Play ' + activity_name, color: '0x7b00ff', position: streaming_role.position, hoist: true });
                }
                await role_manager.add(member, game_role);
                await role_manager.add(member, play_role);
            } else if (play_role) {
                // Remove Play Role from this member
                if (member.roles.cache.has(play_role.id)) {
                    await role_manager.remove(member, play_role);
                }
                // Check if Play Role is still in use
                let role_in_use = false;
                for (const this_member of app.guild().members.cache.array()) {
                    if (this_member.roles.cache.find(role => role == play_role)) {
                        // Check if this member is still playing
                        if (this_member.presence.activities.map(activity => activity.name.trim()).includes(play_role.name.substring(5))) {
                            role_in_use = true;
                        }
                    }
                }
                // Delete inactive Play Roles
                if (!role_in_use) {
                    // Delete Play Role
                    await role_manager.delete(play_role);
                }
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('memberActivityUpdate', error));
    }
    ActivityManager.finish();
}

/**
 * Performs processes that updates the status of this member through this voice state.
 * @param {Discord.GuildMember} member A guild member object.
 * @param {Discord.VoiceState} oldState The old voice state object.
 * @param {Discord.VoiceState} newState The new voice state object.
 */
module.exports.memberVoiceUpdate = async (member, oldState, newState) => {
    await VoiceManager.queue();
    try {
        if (oldState.channel &amp;&amp; oldState.channel.parent.id == constants.channels.category.dedicated) {
            const text_channel = app.channel(constants.channels.category.dedicated).children.find(channel => channel.type == 'text' &amp;&amp; channel.topic &amp;&amp; functions.parseMention(channel.topic.split(' ')[0]) == oldState.channelID);
            const linked_data = text_channel.topic.split(' ');
            const text_role = app.role(linked_data[1]);
            const team_role = app.role(linked_data[2]);

            if (oldState.channel.members.size > 0 &amp;&amp; !(oldState.channel.members.size == 1 &amp;&amp; oldState.channel.members.first().user.bot)) {
                await role_manager.remove(member, text_role);
                await role_manager.remove(member, team_role);
                const embed = new Discord.MessageEmbed();
                embed.setAuthor('Quarantine Gaming: Dedicated Channels');
                embed.setTitle(oldState.channel.name);
                embed.setDescription(`${oldState.member} left this channel.`);
                embed.setThumbnail(member.user.displayAvatarURL());
                embed.setFooter(`${member.user.tag} (${member.user.id})`);
                embed.setTimestamp();
                embed.setColor('#7b00ff');
                await message_manager.sendToChannel(text_channel, embed);
            } else {
                await channel_manager.delete(oldState.channel);
                await channel_manager.delete(text_channel);
                await role_manager.delete(text_role);
                await role_manager.delete(team_role);
            }
        }

        if (newState.channel) {
            // Check if members are streaming
            const streamers = new Array();
            for (const this_member of newState.channel.members.array()) {
                if (member.user.id != this_member.user.id &amp;&amp; this_member.roles.cache.has(constants.roles.streaming)) {
                    streamers.push(this_member);
                }
            }
            // Notify member
            if (streamers.length > 0) {
                const embed = new Discord.MessageEmbed();
                embed.setAuthor('Quarantine Gaming: Information');
                embed.setTitle(`${streamers.length > 1 ? `${streamers.map(member => member.displayName).join(' and ')} are` : `${streamers.map(member => member.displayName)} is`} currently Streaming`);
                embed.setDescription('Please observe proper behavior on your current voice channel.');
                embed.setImage('https://pa1.narvii.com/6771/d33918fa87ad0d84b7dc854dcbf6a8545c73f94d_hq.gif');
                embed.setColor('#5dff00');
                await message_manager.sendToUser(member, embed);
            }

            if (newState.channel.parent.id == constants.channels.category.dedicated) {
                const text_channel = app.channel(constants.channels.category.dedicated).children.find(channel => channel.type == 'text' &amp;&amp; channel.topic &amp;&amp; functions.parseMention(channel.topic.split(' ')[0]) == newState.channelID);
                const linked_data = text_channel.topic.split(' ');
                const text_role = app.role(linked_data[1]);
                const team_role = app.role(linked_data[2]);

                // Add Text Role
                if (!member.roles.cache.has(text_role.id)) {
                    const embed = new Discord.MessageEmbed();
                    embed.setAuthor('Quarantine Gaming: Dedicated Channels');
                    embed.setTitle(newState.channel.name);
                    embed.setDescription(`${newState.member} joined this channel.`);
                    embed.setThumbnail(newState.member.user.displayAvatarURL());
                    embed.setFooter(`${newState.member.user.tag} (${newState.member.user.id})`);
                    embed.setTimestamp();
                    embed.setColor('#7b00ff');
                    await message_manager.sendToChannel(text_channel, embed);
                    await role_manager.add(member, text_role);
                }

                // Add Team Role
                if (!member.roles.cache.has(team_role.id)) {
                    await role_manager.add(member, team_role);
                }

                // Add Dedicated Role
                if (!member.roles.cache.has(constants.roles.dedicated)) {
                    await role_manager.add(member, constants.roles.dedicated);
                }
            } else {
                // Remove Text Role
                if (member.roles.cache.has(constants.roles.dedicated)) {
                    await role_manager.remove(member, constants.roles.dedicated);
                }
            }
        } else {
            // Remove Streaming Role
            if (member.roles.cache.has(constants.roles.streaming)) {
                await role_manager.remove(member, constants.roles.streaming)
            }
            // Remove Text Role
            if (member.roles.cache.has(constants.roles.dedicated)) {
                await role_manager.remove(member, constants.roles.dedicated);
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('memberVoiceUpdate', error));
    }
    VoiceManager.finish();
}

/**
 * Creates a game invite and player bracket.
 * @param {Discord.Role} role The mentionable role.
 * @param {Discord.GuildMember} inviter The member who initiated the invite.
 * @param {Number} count Number of players the inviter is looking for.
 * @param {Array&lt;Discord.GuildMember>} reserved_members List of members that is reserved to this bracket.
 */
module.exports.gameInvite = async (role, inviter, count, reserved_members) => {
    try {
        const mention_role = app.guild().roles.cache.find(this_role => this_role.hexColor == '#00ffff' &amp;&amp; role.name.startsWith(this_role.name));
        if (mention_role) {
            const embed = new Discord.MessageEmbed();
            embed.setAuthor('Quarantine Gaming: Game Coordinator');
            embed.setTitle(mention_role.name);
            embed.addField(`Player 1:`, inviter);

            let reserved_count = 2;
            const members = new Array();
            if (reserved_members.length > 0) {
                for (const this_member of reserved_members) {
                    if (this_member &amp;&amp; !members.includes(this_member)) {
                        members.push(this_member);
                        if (this_member.user.id != inviter.user.id) {
                            embed.addField(`Player ${reserved_count++}:`, this_member);
                        }
                    }
                }
            }
            if (count == 0) {
                embed.setDescription(`${inviter.displayName} wants to play ${mention_role}.`);
            } else {
                embed.setDescription(`${inviter.displayName} is looking for **${count - 1}** other ${mention_role} player${count == 2 ? '' : 's'}.`);
                for (let i = reserved_count; i &lt;= count; i++) {
                    embed.addField(`Player ${i}:`, '\u200B');
                }
            }

            const is_full = count != 0 &amp;&amp; members.length + 1 >= count;
            if (is_full) {
                embed.setFooter('Closed. This bracket is now full.');
            } else {
                embed.setFooter(`Join this bracket by reacting below.`);
            }
            embed.setColor('#7b00ff');

            const emoji = app.guild().emojis.cache.find(emoji => emoji.name == functions.toAlphanumericString(mention_role.name));
            const qg_emoji = app.guild().emojis.cache.find(emoji => emoji.name == 'quarantinegaming');
            if (emoji) {
                embed.setThumbnail(emoji.url);
            } else {
                embed.setThumbnail(qg_emoji.url);
            }

            const this_message = await message_manager.sendToChannel(constants.channels.integrations.game_invites, { content: `${inviter.displayName} is inviting you to play ${mention_role}!`, embed: embed })
            this_message.delete({ timeout: 3600000 }).catch(() => { });
            if (!is_full) {
                await reaction_manager.addReaction(this_message, emoji ? emoji : qg_emoji).catch(error => error_manager.mark(ErrorTicketManager.create('addReaction', error, 'gameInvite')));
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('gameInvite', error));
    }
}

/**
 * Creates a dedicated voice and text channels with a team role connected to it.
 * @param {Discord.VoiceChannel} channel_origin The voice room to transfer to the dedicated channel.
 * @param {String} name The name of the dedicated channel.
 */
module.exports.dedicateChannel = async (channel_origin, name) => {
    await DedicateManager.queue();
    try {
        const channel_name = '🔰' + name;
        if (channel_origin.parentID == constants.channels.category.dedicated) {
            // Rename
            await channel_origin.setName(channel_name);
            const text_channel = app.channel(constants.channels.category.dedicated).children.find(channel => channel.type == 'text' &amp;&amp; channel.topic &amp;&amp; channel.topic.split(' ')[0] == channel_origin.id);
            await text_channel.setName(channel_name);
            const hoisted_role = app.role(text_channel.topic.split(' ')[2]);
            await hoisted_role.setName(`Team ${channel_name}`);

            // Set info
            const channel_desc = new Array();
            channel_desc.push(`• Only members who are in this voice channel can view this text channel.`);
            channel_desc.push(`• You can't view other dedicated channels once you're connected to one.`);
            channel_desc.push(`• ${text_channel} voice and text channels will automatically be deleted once everyone is disconnected from these channels.`);
            channel_desc.push(`• You can lock this channel by doing **!dedicate lock**, and you can do **!dedicate unlock** to unlock it.`);
            channel_desc.push(`• You can transfer anyone from another voice channel to this voice channel by doing **!transfer &lt;@member>**.\n\u200b\u200bEx: "!transfer ${app.client().user}"`);
            channel_desc.push(`• You can also transfer multiple users at once.\n\u200b\u200bEx: "!transfer ${app.client().user} ${app.client().user}"`);
            channel_desc.push(`Note: ${app.role(constants.roles.staff)}, ${app.role(constants.roles.moderator)}, and ${app.role(constants.roles.music_bot)} can interact with these channels.`);
            const embed = new Discord.MessageEmbed();
            embed.setAuthor('Quarantine Gaming: Dedicated Channels');
            embed.setTitle(`Voice and Text Channels for ${channel_name}`);
            embed.setDescription(channel_desc.join('\n\n'));
            embed.setColor('#7b00ff');

            const profile = app.guild().members.cache.find(member => member.displayName == name);
            const emoji = app.guild().emojis.cache.find(emoji => emoji.name == name.split(' ').join('').split(':').join('').split('-').join(''));
            const qg_emoji = app.guild().emojis.cache.find(emoji => emoji.name == 'quarantinegaming');
            if (profile) {
                embed.setThumbnail(profile.user.displayAvatarURL());
            } else if (emoji) {
                embed.setThumbnail(emoji.url);
            } else {
                embed.setThumbnail(qg_emoji.url);
            }

            await message_manager.sendToChannel(text_channel, embed);
        } else {
            // Notify
            await speech.say(`Transferring to ${name} dedicated channel. Please wait.`, channel_origin);

            const p = constants.permissions;
            const dedicated_voice_channel = await channel_manager.create({
                name: channel_name,
                type: 'voice',
                parent: constants.channels.category.dedicated,
                position: 1,
                permissionOverwrites: [
                    {
                        id: constants.roles.everyone,
                        deny: [
                            p.general.CREATE_INVITE,
                            p.general.MANAGE_CHANNELS,
                            p.general.MANAGE_PERMISSIONS,
                            p.general.MANAGE_WEBHOOKS,
                            p.voice.CONNECT,
                            p.voice.MUTE_MEMBERS,
                            p.voice.DEAFEN_MEMBERS,
                            p.voice.MOVE_MEMBERS,
                            p.voice.PRIORITY_SPEAKER
                        ]
                    },
                    {
                        id: constants.roles.dedicated,
                        deny: [
                            p.general.VIEW_CHANNEL
                        ]
                    },
                    {
                        id: constants.roles.member,
                        allow: [
                            p.voice.CONNECT,
                            p.voice.SPEAK,
                            p.voice.VIDEO
                        ],
                    },
                    {
                        id: constants.roles.moderator,
                        allow: [
                            p.general.CREATE_INVITE,
                            p.general.MANAGE_CHANNELS,
                            p.voice.CONNECT,
                            p.voice.MUTE_MEMBERS,
                            p.voice.DEAFEN_MEMBERS,
                            p.voice.MOVE_MEMBERS,
                            p.voice.PRIORITY_SPEAKER
                        ]
                    },
                    {
                        id: constants.roles.music_bot,
                        allow: [
                            p.voice.CONNECT,
                            p.voice.SPEAK,
                            p.voice.USE_VOICE_ACTIVITY
                        ]
                    }
                ],
                bitrate: 128000
            });

            const dedicated_text_role = await role_manager.create({
                name: `Text ${dedicated_voice_channel.id}`
            });

            const team_role = await role_manager.create({
                name: `Team ${channel_name}`,
                position: app.role(constants.roles.dedicated).position,
                hoist: true
            });

            const dedicated_text_channel = await channel_manager.create({
                name: channel_name,
                type: 'text',
                parent: constants.channels.category.dedicated,
                position: 1,
                permissionOverwrites: [
                    {
                        id: constants.roles.everyone,
                        deny: [
                            p.general.VIEW_CHANNEL,
                            p.general.CREATE_INVITE,
                            p.general.MANAGE_CHANNELS,
                            p.general.MANAGE_PERMISSIONS,
                            p.general.MANAGE_WEBHOOKS,
                            p.text.MENTION_EVERYONE,
                            p.text.MANAGE_MESSAGES
                        ]
                    },
                    {
                        id: constants.roles.music_bot,
                        allow: [
                            p.general.VIEW_CHANNEL,
                            p.text.ADD_REACTIONS,
                            p.text.EMBED_LINKS,
                            p.text.SEND_MESSAGES
                        ]
                    },
                    {
                        id: dedicated_text_role.id,
                        allow: [
                            p.general.VIEW_CHANNEL,
                            p.text.SEND_TTS_MESSAGES,
                            p.text.EMBED_LINKS,
                            p.text.ATTACH_FILES,
                        ]
                    },
                    {
                        id: constants.roles.moderator,
                        allow: [
                            p.general.VIEW_CHANNEL,
                            p.general.CREATE_INVITE,
                            p.general.MANAGE_CHANNELS,
                            p.text.MENTION_EVERYONE,
                            p.text.MANAGE_MESSAGES
                        ]
                    },
                ],
                topic: `${dedicated_voice_channel} ${dedicated_text_role} ${team_role}`
            });

            await dedicated_voice_channel.updateOverwrite(dedicated_text_role, {
                VIEW_CHANNEL: true
            });

            // Set info
            const channel_desc = new Array();
            channel_desc.push(`• Only members who are in this voice channel can view this text channel.`);
            channel_desc.push(`• You can't view other dedicated channels once you're connected to one.`);
            channel_desc.push(`• ${dedicated_text_channel} voice and text channels will automatically be deleted once everyone is disconnected from these channels.`);
            channel_desc.push(`• You can lock this channel by doing **!dedicate lock**, and you can do **!dedicate unlock** to unlock it.`);
            channel_desc.push(`• You can transfer anyone from another voice channel to this voice channel by doing **!transfer &lt;@member>**.\n\u200b\u200bEx: "!transfer ${app.client().user}"`);
            channel_desc.push(`• You can also transfer multiple users at once.\n\u200b\u200bEx: "!transfer ${app.client().user} ${app.client().user}"`);
            channel_desc.push(`Note: ${app.role(constants.roles.staff)}, ${app.role(constants.roles.moderator)}, and ${app.role(constants.roles.music_bot)} can interact with these channels.`);
            const embed = new Discord.MessageEmbed();
            embed.setAuthor('Quarantine Gaming: Dedicated Channels');
            embed.setTitle(`Voice and Text Channels for ${channel_name}`);
            embed.setDescription(channel_desc.join('\n\n'));
            embed.setColor('#7b00ff');

            const profile = app.guild().members.cache.find(member => member.displayName == name);
            const emoji = app.guild().emojis.cache.find(emoji => emoji.name == name.split(' ').join('').split(':').join('').split('-').join(''));
            const qg_emoji = app.guild().emojis.cache.find(emoji => emoji.name == 'quarantinegaming');
            if (profile) {
                embed.setThumbnail(profile.user.displayAvatarURL());
            } else if (emoji) {
                embed.setThumbnail(emoji.url);
            } else {
                embed.setThumbnail(qg_emoji.url);
            }

            await message_manager.sendToChannel(dedicated_text_channel, embed);

            // Sort members
            const streamers = [], members = [];
            for (const this_member of channel_origin.members.array()) {
                if (this_member.roles.cache.has(constants.roles.streaming)) {
                    streamers.push(this_member);
                } else {
                    members.push(this_member);
                }
            }
            // Transfer streamers
            for (const this_member of streamers) {
                await this_member.voice.setChannel(dedicated_voice_channel);
                await functions.sleep(1000);
            }
            // Transfer members
            for (const this_member of members) {
                if (this_member.user.id != constants.me) {
                    await this_member.voice.setChannel(dedicated_voice_channel);
                    await functions.sleep(2500);
                }
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('dedicateChannel', error));
    }
    DedicateManager.finish();
}

/**
 * Fetches the first 25 posts then are tested against the database to check for new posts.
 * @param {String} url The specific URL to fetch that ignores the creation date criteria.
 * @returns {String} The status of the fetch when URL is provided.
 */
module.exports.freeGameFetch = async (url = '') => {
    try {
        freeGameCollection = await fetch('https://www.reddit.com/r/FreeGameFindings/new/.json?limit=25&amp;sort=new').then(data => data.json()).then(entry => entry.data.children.map(child => child.data));
        if (freeGameCollection) {
            for (const freeGameData of freeGameCollection) {
                const notification = new classes.Notification(
                    null,
                    functions.parseHTML(freeGameData.title),
                    freeGameData.url,
                    freeGameData.author,
                    `https://www.reddit.com${freeGameData.permalink}`,
                    {
                        createdAt: freeGameData.created_utc,
                        description: functions.parseHTML(freeGameData.selftext),
                        flair: freeGameData.link_flair_text,
                        score: freeGameData.score,
                        validity: freeGameData.upvote_ratio * 100
                    });

                const this_notification = database.notificationRecords(notification);
                if (url) {
                    if (url.trim().toLowerCase() == notification.url.trim().toLowerCase() || url.trim().toLowerCase() == notification.permalink.trim().toLowerCase()) {
                        if (!this_notification) {
                            this.freeGameNotify(notification);
                            return 'Got it! Inserting this entry to processing queue for validation.';
                        } else {
                            return 'This entry is already posted on the free games channel.';
                        }
                    }
                } else {
                    const elapsedMinutes = functions.compareDate(new Date(notification.createdAt * 1000));
                    if (!this_notification &amp;&amp; elapsedMinutes >= 30 &amp;&amp; elapsedMinutes &lt;= 300 &amp;&amp; notification.score >= 50 &amp;&amp; notification.validity >= 75) {
                        this.freeGameNotify(notification);
                    }
                }
            }
            if (url) return 'Uh-oh! The link you provided is no longer valid.';
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('freeGameFetch', error));
    }
}

/**
 * Updates all active notifications.
 */
module.exports.freeGameUpdate = async () => {
    await FreeGameManager.queue();
    try {
        if (freeGameCollection) {
            for (const freeGameData of freeGameCollection) {
                const notification = new classes.Notification(
                    null,
                    functions.parseHTML(freeGameData.title),
                    freeGameData.url,
                    freeGameData.author,
                    `https://www.reddit.com${freeGameData.permalink}`,
                    {
                        createdAt: freeGameData.created_utc,
                        description: functions.parseHTML(freeGameData.selftext),
                        flair: freeGameData.link_flair_text,
                        score: freeGameData.score,
                        validity: freeGameData.upvote_ratio * 100
                    });

                const this_notification = database.notificationRecords(notification);
                if (this_notification) {
                    const message = await app.channel(constants.channels.integrations.free_games).messages.fetch(this_notification.id);
                    if (message) {
                        if (notification.description) {
                            message.embeds[0].spliceFields(1, 3)
                                .addFields([
                                    { name: 'Trust Factor', value: `${notification.validity} %`, inline: true },
                                    { name: 'Margin', value: `${notification.score}`, inline: true },
                                    { name: 'Details', value: `${notification.description}` }
                                ]).setTimestamp();
                        } else {
                            message.embeds[0].spliceFields(1, 2)
                                .addFields([
                                    { name: 'Trust Factor', value: `${notification.validity} %`, inline: true },
                                    { name: 'Margin', value: `${notification.score}`, inline: true }
                                ]).setTimestamp();
                        }
                        if (notification.flair) {
                            if (notification.flair.toLowerCase().indexOf('comment') != -1 || notification.flair.toLowerCase().indexOf('issue') != -1) {
                                message.embeds[0].setDescription(`[${notification.flair}](${notification.permalink})`);
                            } else {
                                message.embeds[0].setDescription(notification.flair);
                            }
                        }
                        await message.edit({ content: message.content, embed: message.embeds[0] });
                    }
                }
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('freeGameUpdate', error));
    }
    FreeGameManager.finish();
}

/**
 * Sends the notification to the free games channel.
 * @param {classes.Notification} notification The notification object to send.
 */
module.exports.freeGameNotify = async (notification) => {
    await FreeGameManager.queue();
    try {
        const title = notification.title;
        const url = notification.url;
        const author = notification.author;
        const description = notification.description;
        const validity = notification.validity;
        const score = notification.score;
        const flair = notification.flair;
        const permalink = notification.permalink;

        const embed = new Discord.MessageEmbed().setTimestamp();
        embed.setAuthor('Quarantine Gaming: Free Game/DLC Notification');
        if (flair) {
            if (flair.toLowerCase().indexOf('comment') !== -1 || flair.toLowerCase().indexOf('issue') !== -1) {
                embed.setDescription(`[${flair}](${permalink})`);
            } else {
                embed.setDescription(flair);
            }
        }
        embed.addFields([
            { name: 'Author', value: author, inline: true },
            { name: 'Trust Factor', value: `${validity} %`, inline: true },
            { name: 'Margin', value: `${score}`, inline: true }
        ]);
        if (description) {
            embed.addField('Details', description);
        }

        // Title
        const safe_title = [], exclude_title = [], filtered_content = [];
        if (title) {
            const words = title.split(' ');
            const filters = ['other', 'alpha', 'beta', 'psa'];
            for (const word of words) {
                // Check if the word is not one of the classifiers
                if (!word.startsWith('[') &amp;&amp; !word.startsWith('(') &amp;&amp; !word.endsWith(']') &amp;&amp; !word.endsWith(')')) {
                    safe_title.push(word);
                } else {
                    exclude_title.push(word);
                    for (const filter of filters) {
                        if (word.toLowerCase().indexOf(filter) !== -1) {
                            filtered_content.push(word);
                        }
                    }
                }
            }
            embed.setTitle(`**${safe_title.length > 0 ? safe_title.join(' ') : title}**`);
        }

        // URL
        embed.setURL(url);
        embed.setFooter(`${new URL(url).hostname} | Updated as of `, functions.fetchIcon(hostname));

        // Image
        const images = await functions.fetchImage(title).catch(() => { });
        for (const image of images) {
            const response = await fetch(image.url).catch(() => { });
            if (response &amp;&amp; response.ok) {
                const probe_result = await probe(image.url, { timeout: 10000 }).catch(() => { });
                if (probe_result) {
                    const width = parseInt(probe_result.width);
                    const height = parseInt(probe_result.height);
                    const ratio = width / height;
                    if (width >= 200 &amp;&amp; height >= 200 &amp;&amp; ratio >= 1.7) {
                        embed.setImage(probe_result.url);
                        break;
                    }
                }
            }
        }
        if (!embed.image.url) embed.setImage(constants.images.free_games_banner);

        const color = {
            R: 0,
            G: 0,
            B: 0,
            add: function (R, G, B) {
                this.R += R;
                this.G += G;
                this.B += B;
                // Scale the colors until its acceptable
                while (this.R > 255 || this.G > 255 || this.B > 255) {
                    if (this.R > 0) this.R--;
                    if (this.G > 0) this.G--;
                    if (this.B > 0) this.B--;
                }
            },
            toHex: function () {
                let red = this.R.toString(16);
                let green = this.G.toString(16);
                let blue = this.B.toString(16);
                if (red.length == 1) red = `0${red}`;
                if (green.length == 1) green = `0${green}`;
                if (blue.length == 1) blue = `0${blue}`;
                return `#${red}${green}${blue}`;
            }
        }

        const mentionables = new Array();
        const searchables = (description ? description.toLowerCase() : '*') + ' ' + (url ? url.toLowerCase() : '*');

        if (functions.contains(searchables, 'steampowered.com')) {
            mentionables.push(constants.roles.steam);
            color.add(0, 157, 255);
        }
        if (functions.contains(searchables, 'epicgames.com')) {
            mentionables.push(constants.roles.epic);
            color.add(157, 255, 0);
        }
        if (functions.contains(searchables, 'gog.com')) {
            mentionables.push(constants.roles.gog);
            color.add(157, 0, 255);
        }
        if (functions.contains(searchables, 'ubisoft.com')) {
            mentionables.push(constants.roles.ubisoft);
            color.add(200, 120, 255);
        }
        const Console_URLs = ['playstation.com', 'wii.com', 'xbox.com', 'microsoft.com'];
        for (const Console_URL of Console_URLs) {
            if (!mentionables.includes(constants.roles.console) &amp;&amp; functions.contains(searchables, Console_URL)) {
                mentionables.push(constants.roles.console);
                color.add(200, 80, 200)
            }
        }

        embed.setColor(color.toHex());
        if (filtered_content.length == 0 &amp;&amp; mentionables.length > 0) {
            const sent_mesage = await message_manager.sendToChannel(constants.channels.integrations.free_games, { content: mentionables.map(mentionable => app.role(mentionable)).join(', '), embed: embed });

            await database.notificationPush(parseNotification(sent_mesage.id, safe_title ? safe_title : title, url, author, permalink));

            await database.notificationPush({
                id: sent_mesage.id,
                title: safe_title ? safe_title : title,
                url: url,
                author: author,
                permalink: permalink
            });

            // Crosspost a message
            if (sent_mesage.channel.type === 'news') {
                await sent_mesage.crosspost();
                const crosspost_embed = new Discord.MessageEmbed();
                crosspost_embed.setColor('#da00ff');
                crosspost_embed.setAuthor('Quarantine Gaming: Free Game/DLC Crossposting');
                crosspost_embed.setTitle(sent_mesage.embeds[0].title);
                crosspost_embed.setDescription('This notification is now published and is visible to all external(following) servers.')
                await message_manager.sendToChannel(constants.channels.qg.logs, crosspost_embed);
            }
        }
    } catch (error) {
        error_manager.mark(ErrorTicketManager.create('freeGameNotify', error));
    }
    FreeGameManager.finish();
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ErrorTicket.html">ErrorTicket</a></li><li><a href="ErrorTicketManager.html">ErrorTicketManager</a></li><li><a href="Notification.html">Notification</a></li><li><a href="ProcessQueue.html">ProcessQueue</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#addReaction">addReaction</a></li><li><a href="global.html#app">app</a></li><li><a href="global.html#blacklisted">blacklisted</a></li><li><a href="global.html#channel">channel</a></li><li><a href="global.html#channel_manager">channel_manager</a></li><li><a href="global.html#clearTempChannels">clearTempChannels</a></li><li><a href="global.html#client">client</a></li><li><a href="global.html#compareArray">compareArray</a></li><li><a href="global.html#compareDate">compareDate</a></li><li><a href="global.html#compareString">compareString</a></li><li><a href="global.html#contains">contains</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createStructure">createStructure</a></li><li><a href="global.html#database">database</a></li><li><a href="global.html#DB">DB</a></li><li><a href="global.html#dedicateChannel">dedicateChannel</a></li><li><a href="global.html#delete">delete</a></li><li><a href="global.html#error_manager">error_manager</a></li><li><a href="global.html#fetchIcon">fetchIcon</a></li><li><a href="global.html#fetchImage">fetchImage</a></li><li><a href="global.html#freeGameFetch">freeGameFetch</a></li><li><a href="global.html#freeGameNotify">freeGameNotify</a></li><li><a href="global.html#freeGameUpdate">freeGameUpdate</a></li><li><a href="global.html#gameBlacklist">gameBlacklist</a></li><li><a href="global.html#gameInvite">gameInvite</a></li><li><a href="global.html#gameTitles">gameTitles</a></li><li><a href="global.html#gameWhitelist">gameWhitelist</a></li><li><a href="global.html#general">general</a></li><li><a href="global.html#guild">guild</a></li><li><a href="global.html#hasRole">hasRole</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initialized">initialized</a></li><li><a href="global.html#isInitialized">isInitialized</a></li><li><a href="global.html#mark">mark</a></li><li><a href="global.html#member">member</a></li><li><a href="global.html#memberActivityUpdate">memberActivityUpdate</a></li><li><a href="global.html#memberOffline">memberOffline</a></li><li><a href="global.html#memberUnlisted">memberUnlisted</a></li><li><a href="global.html#memberVoiceUpdate">memberVoiceUpdate</a></li><li><a href="global.html#message">message</a></li><li><a href="global.html#message_manager">message_manager</a></li><li><a href="global.html#notificationPush">notificationPush</a></li><li><a href="global.html#notificationRecords">notificationRecords</a></li><li><a href="global.html#notifications">notifications</a></li><li><a href="global.html#notificationTrim">notificationTrim</a></li><li><a href="global.html#onReactionAdd">onReactionAdd</a></li><li><a href="global.html#onReactionRemove">onReactionRemove</a></li><li><a href="global.html#parseHTML">parseHTML</a></li><li><a href="global.html#parseMention">parseMention</a></li><li><a href="global.html#parseModules">parseModules</a></li><li><a href="global.html#process">process</a></li><li><a href="global.html#reaction_manager">reaction_manager</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#role">role</a></li><li><a href="global.html#role_manager">role_manager</a></li><li><a href="global.html#say">say</a></li><li><a href="global.html#sendToChannel">sendToChannel</a></li><li><a href="global.html#sendToUser">sendToUser</a></li><li><a href="global.html#setActivity">setActivity</a></li><li><a href="global.html#sleep">sleep</a></li><li><a href="global.html#speech">speech</a></li><li><a href="global.html#toAlphanumericString">toAlphanumericString</a></li><li><a href="global.html#toCountingInteger">toCountingInteger</a></li><li><a href="global.html#whitelisted">whitelisted</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Wed Jan 27 2021 19:14:34 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
